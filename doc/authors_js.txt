## 1Ô∏è‚É£ O que √© `api/authors.js`?

Pense nele como:

> **Um DAO do frontend**

Assim como no backend voc√™ tem:

* `AutorDAO`
* `AutorService`

No frontend, esse arquivo √©:

* o **√∫nico lugar** que sabe **como falar com o backend**
* a tela **n√£o sabe URLs, m√©todos HTTP, nem JSON**

Isso evita bagun√ßa.

---

## 2Ô∏è‚É£ Esta linha aqui

```js
const API_BASE = "http://localhost:18080";
```

### O que √© isso?

* `const` ‚Üí constante (n√£o pode ser reatribu√≠da)
* `API_BASE` ‚Üí endere√ßo base do backend

Voc√™ evita repetir:

```js
"http://localhost:18080/authors"
```

em todo lugar.

Se amanh√£ mudar a porta:
‚û° muda **uma linha s√≥**

---

## 3Ô∏è‚É£ `async` / `await` ‚Äî conceito-chave

Antes de olhar as fun√ß√µes, precisamos entender isso:

### Problema

Chamadas HTTP **demoram**.
JavaScript **n√£o pode travar a tela** esperando resposta.

### Solu√ß√£o

JS usa **Promises** (promessas).

`async/await` √© s√≥ uma forma **mais leg√≠vel** de trabalhar com isso.

Regra simples:

* `async` ‚Üí fun√ß√£o ass√≠ncrona
* `await` ‚Üí ‚Äúespere isso terminar antes de continuar‚Äù

---

## 4Ô∏è‚É£ Fun√ß√£o `listAuthors`

```js
export async function listAuthors() {
```

* `export` ‚Üí permite usar essa fun√ß√£o em outro arquivo
* `async` ‚Üí ela retorna uma **Promise**
* nome claro: lista autores

---

### 4.1 `fetch`

```js
const res = await fetch(`${API_BASE}/authors`);
```

* `fetch` ‚Üí faz uma requisi√ß√£o HTTP
* Por padr√£o:

  * m√©todo: `GET`
  * sem body

Esse comando **n√£o retorna o JSON ainda**, retorna uma **Response**.

`await`:

* o c√≥digo **espera a resposta**
* sem travar o navegador

---

### 4.2 Verificando erro HTTP

```js
if (!res.ok) throw new Error("Erro ao listar autores");
```

* `res.ok` √© `true` para status 200‚Äì299
* Se der 400, 404, 500 ‚Üí `false`

Aqui voc√™ faz:

> ‚ÄúSe deu erro HTTP, pare tudo e avise‚Äù

Isso √© parecido com lan√ßar exce√ß√£o no backend.

---

### 4.3 Convertendo para JSON

```js
return res.json();
```

* Converte o corpo da resposta em objeto JS
* Tamb√©m √© ass√≠ncrono (por isso o `await` impl√≠cito)

O retorno real ser√°:

```js
{
  count: 2,
  data: [ ... ]
}
```

---

## 5Ô∏è‚É£ Fun√ß√£o `createAuthor`

```js
export async function createAuthor(author) {
```

* Recebe um objeto JS:

```js
{
  nome: "Teste",
  email: "teste@teste.com"
}
```

---

### 5.1 `fetch` com POST

```js
const res = await fetch(`${API_BASE}/authors`, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(author)
});
```

Comparando com backend:

| Backend      | Frontend         |
| ------------ | ---------------- |
| JSON request | `JSON.stringify` |
| Content-Type | `headers`        |
| POST         | `method: "POST"` |

O `fetch` **n√£o envia JSON automaticamente**, voc√™ precisa:

1. transformar o objeto em string
2. dizer o tipo

---

### 5.2 Tratamento de erro

```js
if (!res.ok) throw new Error("Erro ao criar autor");
```

Mesma ideia do backend:

* status ‚â† sucesso ‚Üí erro

---

### 5.3 Retorno

```js
return res.json();
```

Aqui voc√™ recebe:

```js
{
  id: 7,
  nome: "...",
  email: "..."
}
```

Isso permite atualizar a tela **sem novo GET**.

---

## 6Ô∏è‚É£ Fun√ß√£o `updateAuthor`

```js
export async function updateAuthor(id, author) {
```

* `id` ‚Üí vem da tela
* `author` ‚Üí objeto com nome/email

---

### 6.1 PUT

```js
const res = await fetch(`${API_BASE}/authors/${id}`, {
  method: "PUT",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(author)
});
```

Note:

* URL muda
* m√©todo muda
* resto √© igual ao POST

---

### 6.2 Sem retorno

```js
if (!res.ok) throw new Error("Erro ao atualizar autor");
```

Como seu backend retorna `204 No Content`,
‚û° n√£o tem `res.json()` aqui.

A fun√ß√£o s√≥:

* **funciona**
* ou **lan√ßa erro**

---

## 7Ô∏è‚É£ Fun√ß√£o `deleteAuthor`

```js
export async function deleteAuthor(id) {
```

---

### 7.1 DELETE

```js
const res = await fetch(`${API_BASE}/authors/${id}`, {
  method: "DELETE"
});
```

* N√£o envia body
* S√≥ a URL j√° identifica o recurso

---

### 7.2 Tratamento de erro

```js
if (!res.ok) throw new Error("Erro ao remover autor");
```

Fim. Simples.

---

## 8Ô∏è‚É£ Como isso √© usado na pr√°tica?

Em uma tela:

```js
import { listAuthors } from "./api/authors.js";

async function carregarAutores() {
  try {
    const result = await listAuthors();
    console.log(result.data);
  } catch (err) {
    alert(err.message);
  }
}
```

üëâ A tela:

* **n√£o sabe** URL
* **n√£o sabe** m√©todo
* s√≥ sabe que existe `listAuthors()`

---

## 9Ô∏è‚É£ Analogia com backend (isso ajuda muito)

| Backend    | Frontend                |
| ---------- | ----------------------- |
| DAO        | `authors.js`            |
| Service    | l√≥gica da tela          |
| Controller | eventos (click, submit) |
| Exception  | `throw new Error()`     |

---
